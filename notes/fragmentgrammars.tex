\documentclass[runningheads,a4paper]{llncs}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage[ngerman]{babel}
\usepackage{enumerate}
\usepackage{marvosym}
\usepackage{gensymb}
\usepackage[bookmarks,bookmarksopen,bookmarksdepth=2]{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
%\usepackage{amsthm}
\usepackage{qtree}
\usepackage{color}
\usepackage{listings}
\usepackage{mathrsfs}
\usepackage{fancyhdr}

\title{Fragment Grammars}
\author{Maximilian Meffert}
\institute{}

\definecolor{anti-flashwhite}{rgb}{0.95, 0.95, 0.96}

\lstset{
basicstyle=\ttfamily,
backgroundcolor=\color{anti-flashwhite}
}

\begin{document}
\maketitle
\begin{center}
\textbf{DISCLAIMER}
\\Still needs proper citation!
\end{center}
\begin{abstract}
These notes summarize ideas on fragments of formal grammars and languages.
\end{abstract}
\noindent
Consider the following code describing some sort of hierarchy:
\begin{lstlisting}
Foo { Bar { Foo {} } }
\end{lstlisting}
we want to formally define all \textit{fragments} (well-formed partial code pieces) of that code, i.e.:
\begin{lstlisting}
Foo { Bar { Foo {} } }  // the code itself
Bar { Foo {} }          // the first piece
Foo {}                  // the second piece
Foo                     // a terminal
Bar                     // another terminal
{                       // yet another terminal
\end{lstlisting}

A \textit{Formal Grammar} is a 4-tuple:
\begin{align*}
G := (V,\Sigma,P,S)
\end{align*}
with:
\begin{itemize}
\item $V$ a finite set of variables
\item $\Sigma$ a finite set of terminal symbols (the alphabet)
\item $P \subseteq (V \cup \Sigma)^+ \times (V \cup \Sigma)^*$ a finite set of production rules $x \rightarrow x'$
\item $S \in V$ a start variable
\item $V \cap \Sigma = \emptyset$ holds
\end{itemize}
and the \textit{Formal Language} generated by a grammar is the set:
\begin{align*}
\mathcal{L}(G) := \{ w \in \Sigma^* | S \Rightarrow_G^* w \}
\end{align*}

A possible grammar for the code above may be:
\begin{align*}
G &= (
\{E,F,B\}
,\{\epsilon, \texttt{Foo}, \texttt{Bar}, \texttt{\{}, \texttt{\}} \}
,P
,E
)
\\P &= \{
E \rightarrow \epsilon
,E \rightarrow F
,E \rightarrow B
,F \rightarrow \texttt{Foo \{} E \texttt{\}}
,B \rightarrow \texttt{Bar \{} E \texttt{\}} \}
\end{align*}
producing the following syntax tree:
\begin{center}
\begin{minipage}{\textwidth}
\Tree [.E [.F \texttt{Foo} \texttt{\{} [.E [.B \texttt{Bar} \texttt{\{} [.E [.F \texttt{Foo} \texttt{\{} [.E $\epsilon$ ] \texttt{\}} ] ] \texttt{\}} ] ] \texttt{\}} ] ]
\end{minipage}
\end{center}
One can observe that each fragment is a derivation not necessarily starting with the initial start variable of the grammar.
From this, we can also assume that each fragment is governed by its own grammar.
For example, the fragments can be generated by grammars derived from the initial grammar just by switching the start variable:
\begin{itemize}
\item
\begin{lstlisting}
Bar { Foo {} }
\end{lstlisting}
$G' = (V_G,\Sigma_G,P_G,B)$
\item
\begin{lstlisting}
Foo {}
\end{lstlisting}
$G'' = (V_G,\Sigma_G,P_G,F)$
\end{itemize}
So for any given grammar there is a set of grammars of which it is also an element:
\begin{align*}
G \in \bigcup\limits_{v \in V_G} (V_G,\Sigma_G,P_G,v)
\end{align*}
Note, that these fragment grammars are restricted to context-free grammars.
Our method of switching start variables assumes $P \subseteq V \times (V \cup \Sigma)^*$.

To also address terminal symbols as fragments, we construct a set of minimal context-free grammars only capable of deriving terminals:
\begin{align*}
\bigcup\limits_{t \in \Sigma_G} (\{V_t\},\{t\},\{V_t \rightarrow t\}, V_t) 
\end{align*}
For example:
\begin{align*}
G''' = (\{ V_\texttt{Foo} \},\{\texttt{Foo}\},\{ V_\texttt{Foo} \rightarrow \texttt{Foo} \}, V_\texttt{Foo})
\end{align*}

Putting both sets together, we obtain the set of all \textit{Fragment Grammar} for a given grammar:
\begin{align*}
F(G) = 
\bigcup\limits_{v \in V_G} (V_G,\Sigma_G,P_G,v)
\cup
\bigcup\limits_{t \in \Sigma_G} (\{V_t\},\{t\},\{V_t \rightarrow t\}, V_t)
\end{align*}

Note, since context-free grammars are closed under union, $\mathcal{F}(G)$ is also context-free.
For our example grammar above the has the fragment grammar:
\begin{align*}
F(G) &= (V,\Sigma,P,S)
\\V &= \{ E,F,B,V_{\epsilon},V_{\texttt{Foo}},V_{\texttt{Bar}},V_{\texttt{\{}},V_{\texttt{\}}} \}
\\\Sigma &= \{ \epsilon, \texttt{Foo}, \texttt{Bar}, \texttt{\{}, \texttt{\}} \}
\\P &= \{ 
E \rightarrow \epsilon
,E \rightarrow F
,E \rightarrow B
,F \rightarrow \texttt{Foo \{} E \texttt{\}}
,B \rightarrow \texttt{Bar \{} E \texttt{\}},
\\&
V_\epsilon \rightarrow \epsilon
,V_\texttt{Foo} \rightarrow \texttt{Foo}
,V_\texttt{Bar} \rightarrow \texttt{Bar}
,V_\texttt{\{} \rightarrow \texttt{\{}
,V_\texttt{\}} \rightarrow \texttt{\}},
\\&
S \rightarrow E
,S \rightarrow F
,S \rightarrow B
,S \rightarrow V_\epsilon
,S \rightarrow V_\texttt{Foo}
,S \rightarrow V_\texttt{Bar}
,S \rightarrow V_\texttt{\{}
,S \rightarrow V_\texttt{\}}
\}
\end{align*}

Now we can also define a \textit{Fragment Language} generated by a given grammar, containing all fragments which can be produced by that grammar:
\begin{align*}
\mathcal{F}(G) 
= \mathcal{L}(F(G))
= \bigcup\limits_{g \in F(G)} \{ w \in \Sigma^* | S_g \Rightarrow_{g}^* w \}
= \bigcup\limits_{g \in F(G)} \mathcal{L}(g)
\end{align*}





\end{document}