\documentclass[runningheads,a4paper]{llncs}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage[ngerman]{babel}
\usepackage{enumerate}
\usepackage{marvosym}
\usepackage{gensymb}
\usepackage[bookmarks,bookmarksopen,bookmarksdepth=2]{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
%\usepackage{amsthm}
\usepackage{qtree}
\usepackage{color}
\usepackage{listings}
\usepackage{mathrsfs}
\usepackage{fancyhdr}

\title{Grammars, Languages \& Fragments}
\author{Maximilian Meffert}
\institute{}

\definecolor{anti-flashwhite}{rgb}{0.95, 0.95, 0.96}

\lstset{
basicstyle=\ttfamily,
backgroundcolor=\color{anti-flashwhite}
}

\begin{document}
\maketitle

\begin{center}
\textbf{DISCLAIMER}
\\Proper Citation Missing!
\end{center}

\begin{abstract}elation between
These notes summarize ideas on the notion of fragments of elements, i.e. words, of formal languages and their generating grammars.
The main thought is, that fragments are not necessarily words of a formal language in the strict sense, that they can be derived in a finite number of steps starting with the start variable of its grammar.
In fact, there must be a superset of the language containing all possible fragments.
\end{abstract}

\section*{Motivation}
Consider the following code describing some sort of interface:
\begin{lstlisting}
interface Foo {
	method Bar;
}
\end{lstlisting}
we want to formally define all \textit{fragments} (well-formed partial code pieces) of that code, i.e.:
\begin{lstlisting}
interface Foo { method Bar; }  // the code itself
method Bar;                    // the first piece
Foo                            // a terminal
Bar                            // another terminal
;                              // yet another terminal
\end{lstlisting}
A \textit{Formal Grammar} is a 4-tuple:
$G := (V,\Sigma,P,S)$
with:
\begin{itemize}
\item $V$ a finite set of variables
\item $\Sigma$ a finite set of terminal symbols (the alphabet)
\item $P \subseteq (V \cup \Sigma)^+ \times (V \cup \Sigma)^*$ a finite set of production rules $x \rightarrow x'$
\item $S \in V$ a start variable
\item $V \cap \Sigma = \emptyset$ holds
\end{itemize}
and the \textit{Formal Language} generated by a grammar is the set:
\begin{align*}
\mathcal{L}(G) := \{ w \in \Sigma^* | S \Rightarrow_G^* w \}
\end{align*}
where $\Rightarrow_G^*$ is the reflexive, transitive closure or the derivation relation $\Rightarrow_G$.
This means, a word $w$ is an element of $\mathcal{L}(G)$ if and only if there exists a finite derivation:
\begin{align*}
S \Rightarrow_G w_1 \Rightarrow_G w_2 \Rightarrow_G ... \Rightarrow_G w
\end{align*} 
The derivation must start with the starting symbol of the grammar and ends with the word containing no variables.
However, this produces a problem.
A possible grammar for the code above may be:
\begin{align*}
G &= (V,\Sigma,P,I)
\\V &= \{N,M,I\}
\\\Sigma &= \{ \texttt{interface}, \texttt{method}, \texttt{Foo}, \texttt{Bar}, \texttt{\{}, \texttt{\}}, \texttt{;} \}
\\P &= \{
\\& N \rightarrow \texttt{Foo},
\\& N \rightarrow \texttt{Bar},
\\& M \rightarrow \texttt{method} N \texttt{;},
\\& I \rightarrow \texttt{interface} N \texttt{\{} M \texttt{\}} 
\\& \}
\end{align*}
It is easy to observe, that there is no derivation starting with $I$ and ending with the fragment $f = \texttt{method Bar;}$.
Thus $f$ is not an element of $\mathcal{L}(G)$.
(Note, we omitting, that another grammar might exist which produces the exact same words and allows derivation of all fragments. 
However, the fact remains, that the given grammar still creates fragments while not allowing a derivation.)

\section*{Fragment Grrammars \& Languages}
The introductory code example produces the following syntax tree:
\begin{center}
\begin{minipage}{\textwidth}
\Tree [.I \texttt{interface}  [.N \texttt{Foo} ] \texttt{\{} [.M \texttt{method} [.N \texttt{Bar} ] \texttt{;} ] \texttt{\}} ]
\end{minipage}
\end{center}
One can observe, that each fragment is produced by an arbitrary derivation, however, not necessarily starting with the defined start variable of the grammar.
From this, we assume that each fragment is governed by its own grammar.
For example, fragments can be generated by slightly altered grammars just switching the start variable.
For instance the grammar $G' = (V_G,\Sigma_G,P_G,M)$ can produce the fragment:
\begin{lstlisting}
method Bar; 
\end{lstlisting}
So for any given grammar there is a set of grammars of which it is also an element:
\begin{align*}
G \in \bigcup\limits_{v \in V_G} \{ (V_G,\Sigma_G,P_G,v) \}
\end{align*}
Note, that these fragment grammars are restricted to context-free grammars.
Our method of switching start variables assumes $P \subseteq V \times (V \cup \Sigma)^*$.

In order, to address terminal symbols as fragments, we construct a set of minimal context-free grammars, each only capable of deriving one terminals
\begin{align*}
\bigcup\limits_{t \in \Sigma_G} \{ (\{V_t\},\{t\},\{V_t \rightarrow t\}, V_t) \}
\end{align*}
For example: $G''' = (\{ V_\texttt{Foo} \},\{\texttt{Foo}\},\{ V_\texttt{Foo} \rightarrow \texttt{Foo} \}, V_\texttt{Foo})$

Since context-free grammars are closed under union, meaning the union is also context-free, we can now create \textit{Fragment Grammar} for a given grammar:
\begin{align*}
F(G) = 
\bigcup\limits_{v \in V_G} (V_G,\Sigma_G,P_G,v)
\cup
\bigcup\limits_{t \in \Sigma_G} (\{V_t\},\{t\},\{V_t \rightarrow t\}, V_t)
\end{align*}
For our example grammar above the has the fragment grammar:
\begin{align*}
F(G) &= (V,\Sigma,P,S)
\\V &= \{ E,F,B,V_{\epsilon},V_{\texttt{Foo}},V_{\texttt{Bar}},V_{\texttt{\{}},V_{\texttt{\}}} \}
\\\Sigma &= \{ \epsilon, \texttt{Foo}, \texttt{Bar}, \texttt{\{}, \texttt{\}} \}
\\P &= \{ 
E \rightarrow \epsilon
,E \rightarrow F
,E \rightarrow B
,F \rightarrow \texttt{Foo \{} E \texttt{\}}
,B \rightarrow \texttt{Bar \{} E \texttt{\}},
\\&
V_\epsilon \rightarrow \epsilon
,V_\texttt{Foo} \rightarrow \texttt{Foo}
,V_\texttt{Bar} \rightarrow \texttt{Bar}
,V_\texttt{\{} \rightarrow \texttt{\{}
,V_\texttt{\}} \rightarrow \texttt{\}},
\\&
S \rightarrow E
,S \rightarrow F
,S \rightarrow B
,S \rightarrow V_\epsilon
,S \rightarrow V_\texttt{Foo}
,S \rightarrow V_\texttt{Bar}
,S \rightarrow V_\texttt{\{}
,S \rightarrow V_\texttt{\}}
\}
\end{align*}

From the fragment grammar, we can now also generate a \textit{Fragment Language}, containing all fragments which can be produced by that grammar:
\begin{align*}
\mathcal{F}(G) 
= \mathcal{L}(F(G))
= \bigcup\limits_{g \in F(G)} \{ w \in \Sigma^* | S_g \Rightarrow_{g}^* w \}
= \bigcup\limits_{g \in F(G)} \mathcal{L}(g)
\end{align*}

Our original language is now a subset of the fragment language:
\begin{align*}
\mathcal{L}(G) \subseteq \mathcal{F}(G) 
\end{align*}

\newpage

\begin{lstlisting}
Artifact < Entity
Set      < Entity
Grammar  < Artifact
Language < Set
Framgent < Artifact

subsetOf   < Set * Set
elementOf  < Artifact * Language
conformsTo < Artifact * Artifact
conformsTo < Language * Artifact
partOf     < Artifact * Artifact

// an arbitrary grammar artifact
aGrammarArtifact : Grammar
aGrammarArtifact = "uri/to/grammar"

// a fragment of the grammar
aFragmentLanguage : Language
aFragmentLanguage conformsTo aGrammarArtifact

// a language generated be the grammar
aLanguage : Language
aLanguage = "uri/to/language"
aLanguage subsetOf aFragmentLanguage
aLanguage conformsTo aGrammarArtifact

// a artifact/word of the language
aLanguageArtifact : Artifact
aLangugaeArtifact = "uri/to/language/artifact"
aLanguageArtifact elementOf aLanguage
aLanguageArtifact conformsTo aGrammarArtifact

// a fragment of the artifact above
aFragment : Fragment
aFragment = "uri/to/language/artifact#fragment"
aFragment elementOf aFragmentLanguage
aFragment partOf aLanguageArtifact
aFramgnet conformsTo aGrammarArtifact
\end{lstlisting}

\end{document}